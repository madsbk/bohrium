#!/usr/bin/env python
import ConfigParser
import subprocess
import argparse
import pprint
import glob
import os

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def msg(text):
    print bcolors.OKGREEN + text + bcolors.ENDC

def get_options(conf_path=None, section="cpu", areas=["compiler_", "_path"]):
    """
    Returns a dict formatted as: {"compiler": {...}, "path": {...}}.
    Containing the values of Bohrium config options in the.
    """

    if not conf_path:
        conf_path = os.sep.join(["$HOME", ".bohrium", "config.ini"])

    conf_path = os.path.expandvars(os.path.expanduser(conf_path))

    conf = ConfigParser.ConfigParser()
    conf.read(conf_path)

    options = {"compiler": {}, "path": {}}
    for option in conf.options(section):
        for area in areas:
            if area in option:
                tag = option.replace(area, "")
                val = conf.get(section, option).replace('"', "")
                options[area.replace("_", "")][tag] = val

    return options

def get_kernels(options):
    """Returns a sorted list of source-files in kernel_path."""

    return sorted(glob.glob("%s%s*.c" % (options["path"]["kernel"], os.sep)))

def list_kernels(options):
    """Prints sorted list of source-files in kernel_path."""

    kernels = get_kernels(options)
    for i, kernel_path in enumerate(kernels):
        print "[%d] %s" % (i, kernel_path)

def kompile(options, nr):
    kernels = get_kernels(options)              # Grab kernel path
    kernel_path = kernels[nr]

    object_fn       = os.path.basename(kernel_path).replace(".c", ".so")
    object_name, _  = os.path.splitext(object_fn)

    existing_objects = []                       # Grab existing objects...
    object_roots = []                           # ...and object roots.
    for root, dirs, files in os.walk(options["path"]["object"]):
        object_roots += dirs
        for filename in (fn for fn in files if object_name in fn):
            existing_objects.append(os.sep.join([root, filename]))

    if len(object_roots) > 1:
        print ("Warning: Multiple object roots.")
    elif len(object_roots) == 0:
        print ("Warning: No object root")

    object_path = os.sep.join([
        options["path"]["object"], object_roots[0], object_fn
    ])

    cmd = options["compiler"]["cmd"].split(" ") # Setup compile command
    cmd += [kernel_path]
    cmd += options["compiler"]["lib"].split(" ")
    cmd += options["compiler"]["flg"].split(" ")
    cmd += options["compiler"]["ext"].split(" ")
    cmd += options["compiler"]["inc"].split(" ")
    cmd += ["-o", object_path]

    cmd = [c for c in cmd if c]                 # Remove empty entries

    p = subprocess.Popen(cmd)                   # Invoke compiler
    p.communicate()

def kernel_editor(options, nr):
    kernels = get_kernels(options)              # Grab kernel path
    kernel_path = kernels[nr]

    EDITOR = os.environ.get('EDITOR', 'vim')

    p = subprocess.call(
        [EDITOR, kernel_path],
    )

def main():

    parser = argparse.ArgumentParser(description='Invoke the backend compiler on CAPE generated kernels.')
    parser.add_argument('-e', action="store_true", help="Open kernel with default editor")
    parser.add_argument('nr', nargs='?', type=int, help="Compile kernel #NR")

    args = parser.parse_args()

    options = get_options() # Grab options from configuration file
    if args.nr is None:
        msg("* Listing kernels *")
        list_kernels(options)
    else:

        kernels = get_kernels(options)
        if args.nr >= len(kernels):
            msg("* Invalid kernel #NR *")
        else:
            if args.e:
                kernel_editor(options, args.e)
            else:
                msg("* Compiling [%d] %s *" % (args.nr, kernels[args.nr]))
                kompile(options, args.nr)
            
if __name__ == "__main__":
    main()
