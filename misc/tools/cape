#!/usr/bin/env python
import ConfigParser
import subprocess
import argparse
import pprint
import glob
import os

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def msg(text):
    print bcolors.OKGREEN + text + bcolors.ENDC

def get_options(conf_path=None, section="cpu", areas=["compiler_", "_path"]):
    """
    Returns a dict formatted as: {"compiler": {...}, "path": {...}}.
    Containing the values of Bohrium config options in the.
    """

    if not conf_path:
        conf_path = os.sep.join(["$HOME", ".bohrium", "config.ini"])

    conf_path = os.path.expandvars(os.path.expanduser(conf_path))

    conf = ConfigParser.ConfigParser()
    conf.read(conf_path)

    options = {"compiler": {}, "path": {}}
    for option in conf.options(section):
        for area in areas:
            if area in option:
                tag = option.replace(area, "")
                val = conf.get(section, option).replace('"', "")
                options[area.replace("_", "")][tag] = val

    return options

def get_kernels(options):
    """Returns a sorted list of source-files in kernel_path."""

    return sorted(glob.glob("%s%s*.c" % (options["path"]["kernel"], os.sep)))

def list_kernels(options):
    """Prints sorted list of source-files in kernel_path."""

    kernels = get_kernels(options)
    for i, kernel_path in enumerate(kernels):
        print "[%d] %s" % (i, kernel_path)

def object_inventory(options, object_name):
    """Searches object_path for existing instantiations or kernel/object."""

    existing_objects = []                       # Grab existing objects...
    object_roots = []                           # ...and object roots.
    for root, dirs, files in os.walk(options["path"]["object"]):
        object_roots += dirs
        for filename in (fn for fn in files if object_name in fn):
            existing_objects.append(os.sep.join([root, filename]))

    return existing_objects, object_roots

def kernel_compile(options, num):
    """Invoke the backend compiler for kernel # num."""

    kernels = get_kernels(options)              # Grab kernel path
    kernel_path = kernels[num]

    object_fn = os.path.basename(kernel_path).replace(".c", ".so")
    object_name, _ = os.path.splitext(object_fn)

    existing_objects, object_roots = object_inventory(options, object_name)

    if len(object_roots) > 1:
        print "Warning: Multiple object roots."
    elif len(object_roots) == 0:
        print "Warning: No object root"

    for existing_object in existing_objects:
        Cli.info(" * Overwriting: %s" % existing_object)

    object_path = os.sep.join([
        options["path"]["object"], object_roots[0], object_fn
    ])

    cmd = options["compiler"]["cmd"].split(" ")         # Setup command
    cmd += [kernel_path]
    cmd += options["compiler"]["lib"].split(" ")
    cmd += options["compiler"]["flg"].split(" ")
    cmd += options["compiler"]["ext"].split(" ")
    cmd += options["compiler"]["inc"].split(" ")
    cmd += ["-o", object_path]

    process = subprocess.Popen([c for c in cmd if c])   # Invoke compiler
    process.communicate()

def kernel_editor(options, num):
    """Open editor ($EDITOR) for kernel # num."""

    kernels = get_kernels(options)              # Grab kernel path
    kernel_path = kernels[num]

    editor = os.environ.get('EDITOR', 'vim')

    res = subprocess.call(
        [editor, kernel_path],
    )
    if res:
        Cli.fail("* Failered opening editor, set env-var $EDITOR. *")

def main():
    """Script entry: argument parsing and dispatch."""

    parser = argparse.ArgumentParser(
        description='Invoke the backend compiler on CAPE generated kernels.'
    )
    parser.add_argument(
        '-e',
        action="store_true",
        help="Open kernel with default editor"
    )
    parser.add_argument(
        'num',
        nargs='?',
        type=int,
        help="Compile kernel #num"
    )

    args = parser.parse_args()

    options = get_options() # Grab options from configuration file
    if args.num is None:
        Cli.info("* Listing kernels *")
        list_kernels(options)
    else:

        kernels = get_kernels(options)
        num = args.num
        if num >= len(kernels):
            Cli.fail("* Invalid kernel #num *")
        else:
            if args.e:
                kernel_editor(options, num)
            else:
                Cli.info("* Compiling [%d] %s *" % (num, kernels[num]))
                kernel_compile(options, num)

if __name__ == "__main__":
    main()
