#!/usr/bin/env python
"""
    This tools is meant as an aid to debugging and analysing the kernels
    generated with the cape/cpu engine.

    * List kernels: ./cape
    * Compile kernel number 2: ./cape 2
    * Open kernel number 2 in $EDITOR: ./cape 2 -e

    If you want to change compilation parameters, such as adding optimization
    reports, changing optimization level, debug info etc. then simply modify
    the bohrium config file.

    It is thus a handy way to explore potential modifications to the
    CAPE codegenerator, analyzing, debugging, and dumping auxilary information.

    NOTE: When compiling a kernel all existing instantiations of that kernel
    are removed. This is done via os.remove(), not with "rm -rf" so it is
    only semi-dangerous.
"""
import ConfigParser
import subprocess
import argparse
import glob
import sys
import os

DEFAULT_EDITOR = "vim"

class Msg(object):
    """
    Helper for printing text using ANSI[1] escape code

    [1] https://en.wikipedia.org/wiki/ANSI_escape_code
    """

    RESET = '\033[0m'
    BOLD = '\033[1m'
    FAINT = '\033[2m'
    ITALIC = '\033[3m'
    UNDERLINE = '\033[4m'
    RED_HI = '\033[91m'
    GREEN_HI = '\033[92m'
    YELLOW_HI = '\033[93m'
    BLUE_HI = '\033[94m'
    PURPLE_HI = '\033[95m'

    def __init__(self):
        pass

    @staticmethod
    def info(*msgs):
        """Print an informational message."""
        print " ".join(msgs)

    @staticmethod
    def emph(*msgs):
        """Print an emphasized message."""
        head, tail = msgs[0], " " + " ".join(msgs[1:]) if msgs[1:] else ""
        print Msg.BOLD + Msg.BLUE_HI + "** "+ head +" **"+ Msg.RESET + tail

    @staticmethod
    def good(*msgs):
        """Print an green/good message."""
        head, tail = msgs[0], " " + " ".join(msgs[1:]) if msgs[1:] else ""
        print Msg.GREEN_HI + head + Msg.RESET + tail

    @staticmethod
    def warn(*msgs):
        """Print a YELLOW_HI message."""
        head, tail = msgs[0], " " + " ".join(msgs[1:]) if msgs[1:] else ""
        print Msg.YELLOW_HI + head + Msg.RESET + tail

    @staticmethod
    def fail(*msgs):
        """Print a failure message."""
        head, tail = msgs[0], " " + " ".join(msgs[1:]) if msgs[1:] else ""
        print Msg.RED_HI + head + Msg.RESET + tail

def prompt(msg=None):
    """Prompt the user for confirmation, choises: [Yes/No/All]"""

    if msg is None:
        msg = "Are you sure? [Yes|No|All] "
        
    response = raw_input(msg).lower().strip()
    confirmed_all = response != "" and response[0] == "a"
    confirmed = confirmed_all or response == "" or response[0] == "y"

    return confirmed, confirmed_all

def get_options(conf_path=None, section="cpu", areas=None):
    """
    Returns a dict formatted as: {"compiler": {...}, "path": {...}}.
    Containing the values of Bohrium config options in the.
    """

    if conf_path is None:
        conf_path = os.sep.join(["$HOME", ".bohrium", "config.ini"])

    if areas is None:
        areas = ["compiler_", "_path"]

    conf_path = os.path.expandvars(os.path.expanduser(conf_path))

    conf = ConfigParser.ConfigParser()
    conf.read(conf_path)

    options = {"compiler": {}, "path": {}}
    for option in conf.options(section):
        for area in areas:
            if area in option:
                tag = option.replace(area, "")
                val = conf.get(section, option).replace('"', "")
                options[area.replace("_", "")][tag] = val

    return options

def get_kernels(options):
    """Returns a sorted list of source-files in kernel_path."""

    return sorted(glob.glob("%s%s*.c" % (options["path"]["kernel"], os.sep)))

def object_inventory(options, object_name):
    """Searches object_path for existing instantiations or kernel/object."""

    existing_objects = []                       # Grab existing objects...
    object_roots = []                           # ...and object roots.
    for root, dirs, files in os.walk(options["path"]["object"]):
        object_roots += dirs
        for filename in (fn for fn in files if object_name in fn):
            existing_objects.append(os.sep.join([root, filename]))

    return existing_objects, object_roots

def cmd_compile(args, options):
    """Invoke the backend compiler for kernel # num."""

    kernels = get_kernels(options)      # Grab kernels
    numbers = args.num

    if not numbers:                     # Compile all when none is provided
        numbers = range(0, len(kernels))

    Msg.emph("Compiling %d kernel(s)" % len(numbers))
    for num in numbers:
        kernel_path = kernels[num]                  # Grab path to kernel #num
        kernel_fn = os.path.basename(kernel_path)

        Msg.good("Kernel [%d]:" % num, kernel_path)

        object_name = kernel_fn[:-9]                # Strip _r4nDuM.c
        object_fn = "%s_MANUAL.so" % object_name

        existing_objects, object_roots = object_inventory(
            options,
            object_name
        )

        if len(object_roots) > 1:
            Msg.warn("Warning:", "Multiple object roots, using the first.")
        elif len(object_roots) == 0:
            Msg.fail("Aborting compilation:", "Unknown object root.")
            return

        object_path = os.sep.join([
            options["path"]["object"], object_roots[0], object_fn
        ])

        for existing_object in existing_objects:        # Remove objects
            Msg.warn("Removing:", existing_object)
            os.remove(existing_object)

        cmd = options["compiler"]["cmd"].split(" ")     # Setup command
        cmd += [kernel_path]
        cmd += options["compiler"]["lib"].split(" ")
        cmd += options["compiler"]["flg"].split(" ")
        cmd += options["compiler"]["ext"].split(" ")
        cmd += options["compiler"]["inc"].split(" ")
        cmd += ["-o", object_path]

        Msg.good("Creating:", object_path)
        try:                                            # Invoke compiler
            process = subprocess.Popen([c for c in cmd if c])
            process.communicate()
        except OSError as exception:
            Msg.fail("Failed:", "Executing compiler, check bohrium configuration.")
            Msg.fail("Details:", str(exception))

def cmd_edit(args, options):
    """Open editor ($EDITOR) for kernel # num."""

    kernels = get_kernels(options)              # Grab kernels
    kernel_path = kernels[args.num]             # Grab kernel #num

    editor = os.environ.get('EDITOR')
    if not editor:
        Msg.warn("Env $EDITOR is not set, defaulting to %s" % DEFAULT_EDITOR)
        editor = DEFAULT_EDITOR

    try:
        subprocess.call(
            [editor, kernel_path],
        )
    except OSError as exception:
        Msg.fail("Failed:", "opening kernel with $EDITOR(%s)." % editor)
        Msg.fail("Details: %s" % str(exception))

def cmd_rm(args, options):
    """Remove objects related to kernel # num."""

    kernels = get_kernels(options)      # Grab kernels
    numbers = args.num
    force = args.f

    if not numbers:                     # Compile all when none is provided
        numbers = range(0, len(kernels))

    for num in numbers:
        kernel_path = kernels[num]
        kernel_fn = os.path.basename(kernel_path)
        object_name = kernel_fn[:-9]

        objects, _ = object_inventory(options, object_name)
        Msg.emph("Removing %d instantiation(s) of kernel #%d" % (
            len(objects), num
        ))
        
        for obj in objects:
            Msg.warn("Removing:", obj)

            confirmed = force
            if not force:
                confirmed, confirmed_all = prompt()
                force = confirmed_all

            if confirmed:
                os.remove(obj)

def cmd_ls(args, options):
    """Prints sorted list of source-files in kernel_path."""

    kernels = get_kernels(options)

    Msg.emph("Listing kernels")
    for i, kernel_path in enumerate(kernels):
        Msg.info("[%d] %s" % (i, kernel_path))

def main():
    """Script entry: argument parsing and dispatch."""

    parser = argparse.ArgumentParser(
        description='Manual instrumentation of CAPE backend compiler.'
    )

    subparsers = parser.add_subparsers(help='CAPE commands')


    parser_compile = subparsers.add_parser( # Compiler arguments
        'compile',
        help='Compile kernel(s) (generated source)'
    )
    parser_compile.add_argument(
        'num',
        nargs='*',
        type=int,
        help='#num of the kernel to compile'
    )
    parser_compile.set_defaults(func=cmd_compile)

    parser_edit = subparsers.add_parser(    # $EDITOR arguments
        'edit',
        help='Open kernel in $EDITOR'
    )
    parser_edit.add_argument(
        'num',
        type=int,
        help='#num of the kernel to open in $EDITOR'
    )
    parser_edit.set_defaults(func=cmd_edit)

    parser_compile = subparsers.add_parser( # Compiler arguments
        'ls',
        help='List kernels'
    )
    parser_compile.set_defaults(func=cmd_ls)

    parser_rm = subparsers.add_parser(      # Removal of artifacts
        'rm',
        help='Remove instantiated kernels (objects/.so)'
    )
    parser_rm.add_argument(
        'num',
        nargs='*',
        type=int,
        help='baz help'
    )
    parser_rm.add_argument('-f', help='Force removal (do not prompt)')
    parser_rm.set_defaults(func=cmd_rm)

    if len(sys.argv) == 1:  # Print help when no sub-command or help is given
        parser.print_help()
        sys.exit(1)

    options = get_options() # Grab options from configuration file

    args = parser.parse_args()  # Parse arguments
    args.func(args, options)    # Call command "cmd_*(args, options)"

if __name__ == "__main__":
    main()
