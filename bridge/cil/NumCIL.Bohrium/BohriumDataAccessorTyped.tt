<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
#region Autogen notice
/****************************************************************
 *         This file is autogenerated, do not modify!           *
 ****************************************************************/
#endregion
#region Copyright
/*
This file is part of Bohrium and copyright (c) 2013 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with Bohrium. 

If not, see <http://www.gnu.org/licenses/>.
*/
#endregion
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using NumCIL.Generic;

<#
	var types = new[] {
		new KeyValuePair<string, string>("bool8", "System.Boolean"),

		new KeyValuePair<string, string>("int8" , "System.SByte"),
		new KeyValuePair<string, string>("int16", "System.Int16"),
		new KeyValuePair<string, string>("int32", "System.Int32"),
		new KeyValuePair<string, string>("int64", "System.Int64"),

		new KeyValuePair<string, string>("uint8" , "System.Byte"),
		new KeyValuePair<string, string>("uint16", "System.UInt16"),
		new KeyValuePair<string, string>("uint32", "System.UInt32"),
		new KeyValuePair<string, string>("uint64", "System.UInt64"),

		new KeyValuePair<string, string>("float32", "System.Single"),
		new KeyValuePair<string, string>("float64", "System.Double"),

		new KeyValuePair<string, string>("complex64", "NumCIL.Complex64.DataType"),
		new KeyValuePair<string, string>("complex128", "System.Numerics.Complex"),
	};

	var floats = new [] { "float32", "float64" };
	var complexes = new [] { "complex64", "complex128" };

#>
namespace NumCIL.Bohrium
{
    internal static partial class RandomSuppliers
    {
        private static ulong m_seed;
        private static ulong m_index = 0;

        static RandomSuppliers()
        {
            var bytes = new byte[8];
            new Random().NextBytes(bytes);
            m_seed = BitConverter.ToUInt64(bytes, 0);
        }

        public static bool Random<T>(NdArray<T> target)
        {
<# foreach(var kp in types) { #>
			if (typeof(T) == typeof(<#= kp.Value #>))
			{
				Random((NdArray<<#= kp.Value#>>)(object)target);
				return true;
			}
<# } #>
 			return false;
        }
	}

    internal static partial class RangeSuppliers
    {
        public static bool Range<T>(NdArray<T> target)
        {
<# foreach(var kp in types) { #>
			if (typeof(T) == typeof(<#= kp.Value #>))
			{
				Range((NdArray<<#= kp.Value#>>)(object)target);
				return true;
			}
<# } #>
 			return false;
        }
    }


    partial class NameMapper
    {
		private static readonly KeyValuePair<Type, string>[] typenamemap = 
		{
<# foreach(var kp in types) { #>
			new KeyValuePair<Type, string>(typeof(<#= kp.Value #>), "<#= kp.Key #>"),
<# } #>
		};

		private static readonly KeyValuePair<Type, Type>[] pointertypemap = 
		{
<# foreach(var kp in types) { #>
			new KeyValuePair<Type, Type>(typeof(<#= kp.Value #>), typeof(PInvoke.bhc_ndarray_<#= kp.Key #>_p)),
<# } #>
		};

    }

    /// <summary>
    /// Basic factory for creating Bohrium accessors
    /// </summary>
    /// <typeparam name="T">The type of data kept in the underlying array</typeparam>
    public class BohriumAccessorFactory<T> : NumCIL.Generic.IAccessorFactory<T>
    {
        /// <summary>
        /// Creates a new accessor for a data chunk of the given size
        /// </summary>
        /// <param name="size">The size of the array</param>
        /// <returns>An accessor</returns>
        public IDataAccessor<T> Create(long size) 
        { 
            if (size == 1)
                return new DefaultAccessor<T>(size);
<# foreach(var kp in types) { #>
            if (typeof(T) == typeof(<#= kp.Value #>))
                return (IDataAccessor<T>)new DataAccessor_<#= kp.Key #>(size); 
<# } #>
            return new DefaultAccessor<T>(size);
        }

        /// <summary>
        /// Creates a new accessor for a preallocated array
        /// </summary>
        /// <param name="data">The data to wrap</param>
        /// <returns>An accessor</returns>
        public IDataAccessor<T> Create(T[] data)
        {                
            if (data.Length == 1)
                return new DefaultAccessor<T>(data);
                
<# foreach(var kp in types) { #>
            if (typeof(T) == typeof(<#= kp.Value #>))
                return (IDataAccessor<T>)new DataAccessor_<#= kp.Key #>((<#= kp.Value #>[])(object)data); 
<# } #>
            return new DefaultAccessor<T>(data);
        }
    }

<#
foreach(var kp in types) {
	var tdata = kp.Value;
    var prefix = "bhc_ndarray_" + kp.Key;
    var tpointer = prefix + "_p";
    var twrapper = prefix + "_wrapper";
#>
	/// <summary>
	/// The data accessor which transports data between CIL and Bohrium
	/// </summary>
    internal partial class DataAccessor_<#= kp.Key #> : BohriumDataAccessorBase<<#= kp.Value #>, PInvoke.<#= tpointer #>, PInvoke.<#= twrapper #>>
    {
		public DataAccessor_<#= kp.Key #>(<#= tdata #> value, long size) : base(value, size) { }

		public DataAccessor_<#= kp.Key #>(long size) : base(size) { }

		public DataAccessor_<#= kp.Key #>(<#= tdata #>[] data) : base(data) { }

		override protected PInvoke.<#= tpointer #> NewFromValue(<#= kp.Value #> value, ulong size)
		{
			lock(PinnedArrayTracker.ExecuteLock)
			{
				var res = PInvoke.bhc_new_A<#= kp.Key #>(size);
				PInvoke.bhc_identity_A<#= kp.Key #>_K<#= kp.Key #>(res, value);
				return res;
			}
		}

		override protected PInvoke.<#= tpointer #> NewFromEmpty(ulong size)
		{
			lock(PinnedArrayTracker.ExecuteLock)
				return PInvoke.bhc_new_A<#= kp.Key #>(size);
		}
    }


    partial class RandomSuppliers
    {
        public static void Random(NdArray<<#= tdata #>> target)
        {
            lock(PinnedArrayTracker.ExecuteLock)
            {
				var targetshape = new Shape(target.Shape.Dimensions.Select(x => x.Length).ToArray());
                using(var view = (PInvoke.<#= tpointer #>)target.WrapWithPointer())
                using (var tmp = PInvoke.bhc_new_Auint64((ulong)targetshape.Length))
				using (var tmpv = PInvoke.bhc_view_Auint64(tmp, (ulong)targetshape.Dimensions.Length, 0, targetshape.Dimensions.Select(x => x.Length).ToArray(), targetshape.Dimensions.Select(x => x.Stride).ToArray()))
                {
                	PInvoke.bhc_random123_Auint64_Kuint64_Kuint64(tmp, m_index, m_seed);
                    m_index += (ulong)targetshape.Length;
                    PInvoke.bhc_identity_A<#= kp.Key #>_Auint64(view, tmpv);
<# if (floats.Union(complexes).Contains(kp.Key)) { #>
                    PInvoke.bhc_divide_A<#= kp.Key #>_A<#= kp.Key #>_K<#= kp.Key #>(view, view, ulong.MaxValue);
<# } #>
                }
            }
        }
    }

    partial class RangeSuppliers
    {
        public static void Range(NdArray<<#= tdata #>> target)
        {
            lock(PinnedArrayTracker.ExecuteLock)
            {    
                var len = target.DataAccessor.Length;
                using(var a = (PInvoke.<#= tpointer #>)target.WrapWithPointer())
                using(var view = PInvoke.bhc_view_A<#= kp.Key #>(a, 1, 0, new long[] { len }, new long[] { 1 }))
                using (var tmp = PInvoke.bhc_new_Auint64((ulong)len))
                {
                	PInvoke.bhc_range_Auint64(tmp);
                    PInvoke.bhc_identity_A<#= kp.Key #>_Auint64(view, tmp);
                }
            }
        }
    }

    partial class PInvoke
    {
    
		internal class <#= twrapper #> : ITypedMultiArrayMapper<<#= tpointer #>>
		{
			public bool IsAllocated(<#= tpointer #> self) { return self.Pointer != IntPtr.Zero; }
			public <#= tpointer #> NewView(<#= tpointer #> self, ulong rank, long offset, long[] dimensions, long[] stride) { return PInvoke.bhc_view_A<#= kp.Key #>(self, rank, offset, dimensions, stride); }
			public <#= tpointer #> NewEmpty(ulong size) { return PInvoke.bhc_new_A<#= kp.Key #>(size); }
			public void Destroy(<#= tpointer #> self) { PInvoke.bhc_destroy_A<#= kp.Key #>(self); }
			public void Sync(<#= tpointer #> self) { PInvoke.bhc_sync_A<#= kp.Key #>(self); }
			public IntPtr GetData(<#= tpointer #> self) { return PInvoke.bhc_data_get_A<#= kp.Key #>(self, false, false); }
			public void SetData(<#= tpointer #> self, IntPtr data) { PInvoke.bhc_data_set_A<#= kp.Key #>(self, data); }
			public void Copy(<#= tpointer #> self, <#= tpointer #> source) { PInvoke.bhc_identity_A<#= kp.Key #>_A<#= kp.Key #>(self, source); }

		}

	    /// <summary>
	    /// The multi-array instance
	    /// </summary>
	    internal struct <#= tpointer #> : IMultiArray
	    {
	    	/// <summary>
	    	/// The mapper instance with PInvoke functions
	    	/// </summary>
			public static <#= twrapper #> Mapper = new <#= twrapper #>();

	        /// <summary>
	        /// The internal pointer instance
	        /// </summary>
	        private IntPtr pointer;

	        /// <summary>
	        /// Gets the underlying multi array pointer
	        /// </summary>
	        public IntPtr Pointer { get { return pointer; } set { pointer = value; } }

	        /// <summary>
	        /// Constructs a multi_array from an IntPtr
	        /// </summary>
	        public <#= tpointer #>(IntPtr value) { pointer = value; }

        	/// <summary>
	        /// Constructs a multi_array from an NdArray
	        /// </summary>
	        public <#= tpointer #>(NdArray<<#= tdata #>> value) { pointer = BohriumMultiArrayBase<<#= tdata #>, <#= tpointer #>, <#= twrapper #>>.CreateNewView(value).pointer; }

	        /// <summary>
	        /// Disposes the resources held by this instance
	        /// </summary>
			public void Dispose()
			{
				try
				{
					BohriumMultiArrayBase<<#= tdata #>, <#= tpointer #>, <#= twrapper #>>.Dispose(this);
				}
				finally
				{
					pointer = IntPtr.Zero;
				}
			}

	        /// <summary>
	        /// Executes all pending instructions and syncs the data pointer
	        /// </summary>
			public void Sync()
			{
				BohriumMultiArrayBase<<#= tdata #>, <#= tpointer #>, <#= twrapper #>>.Sync(this);
			}
	    }

        /// <summary>
        /// Gets the data pointer from a view
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static IntPtr bhc_data_get_A<#= kp.Key #>([In] <#= tpointer #> self, [In] bool force_alloc, [In] bool nullify);

        /// <summary>
        /// Sets the data pointer for a view
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bhc_data_set_A<#= kp.Key #>([In] <#= tpointer #> self, [In] IntPtr data);

        /// <summary>
        /// Construct a new empty array 
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static <#= tpointer #> bhc_new_A<#= kp.Key #>([In] ulong size);

        /// <summary>
        /// Destroy the pointer and release resources
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bhc_destroy_A<#= kp.Key #>([In] <#= tpointer #> self);

        /// <summary>
        /// Construct a new view from an existing array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static <#= tpointer #> bhc_view_A<#= kp.Key #>([In] <#= tpointer #> source, [In] ulong rank, [In] long offset, [In] long[] sizes, [In] long[] strides);
    }
<# 
} 
#>

}
